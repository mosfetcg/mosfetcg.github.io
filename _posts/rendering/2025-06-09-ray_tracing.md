---
layout: page
title:  "光线追踪-过往明日"
author: mosfet
category: rendering
tags: 渲染 全局照明 路径追踪
---

<style>code:not(pre code) {color:green!important}</style>

## refs
```
cs348b: Image Synthesis Techniques
             REFS
光线追踪    - lecture1,2
高级直接照明 - lectrue10,11, pbrt12
经典全局照明 - lectrue12, focg23
```

## 光线追踪
最初与光线追踪相关的渲染算法可追溯到`Ray casting(Appel-1968)`：  
①每像素发出**一条**光线用于寻找对象。  
②在表面另向光源发出**一条**阴影光线检查照明贡献。  

现代术语中这两个过程的目的称为可见性和着色(照明和阴影模型)。由两条主要光线分别完成。这种算法也被划为图像顺序渲染类型，因其典型的迭代方式。  
几个如今熟悉的概念在这里已经存在或揭示，如shadowRay、光源、Scene Object，相机投射的光线称为view ray。现在我们可能习惯更明确的方式定义它们。  

下一个进展来自于`An improved Illumination
model for shaded display(Whitted-1979)`。  
追踪器的主要改动如下：  
①除了镜子或玻璃，否则总是向光源发送阴影光线。  
②为镜子或玻璃，递归生成新光线(反射或透射)。  
```cpp
// Ray Tracing
Whitted(ray) {
  L = 0; // 程序层面：顶级堆栈父级评估的表达式，有时需要开始递归调用求解未知量(重用条件分支)，有时结束并归还给上一级使其评估
  if hit_any {
    if glass_or_mirror               // 改变光线路径，不贡献光照
      return Whitted(_ray_);
    else if light_not_shadowed       // 若为普通表面，检查遮挡并计算光照 
      L += scatteredIllumination;    // 表示要将光线弹射到光源，可使用简单的直接照明计算，归还给上一级L并计入"总和"(如果存在弹射)
  }
  return L;
}
```
注意到，新说明的镜子和玻璃不计算光照而改变路径，命中普通对象会结束调用。在一系列路径上，会逐步传播最后的结果。  

现代光线追踪中，`路径追踪(path tracing)`被称为一种"Random Walk"，根据渲染方程，其累积值类似为以下程序：  
```cpp
// Path Tracing
PathTrace(ray) {
  L = 0;
  if hit_any {
    L += add_surface_emission;                       // 1
    L += reflection * PathTrace(Direction());        // 2
  }
  return L;
}
```
有趣之处在于路径追踪允许对各种不同材料的建模，使得第二步进一步与之前的方法以及实现方式区分开来，因为某些行为需要随机采样，这导致了对其"随机摸索"的某种描述。  
如果不是直接命中光源，通常Le仅在最后命中发光表面(并不是绝对事件)出现一次计入。另外，该代码的逻辑不完整，因为必须声明停止调用，通常遇到Le时，第二部分会被忽略并完成归还。该示例仅说明`L+=`的累积方式，因此，总和中的每个贡献量从光源到初始位置应呈现递减，除非反射率大于1。  

**布林法(Blinn's Law)**  
科技进步时，渲染时间不变。  
As technology advances, rendering time remains constant.  

## 高级直接照明
#### 非均匀蒙特卡洛估值
在辐射度篇，我们给出了积分估值器`∫S|fdu = EST(fdui/pdui)`的简要概述，而该定义的证明仅进行了引用，如果您感觉的您理论在这里出现了疑问，那你是对的。我们刻意将实践问题和理解留到这里。  
我们做过许多数值方法的小实验，对于蒙特卡洛我们以**25-11**进行说明，以下是一些小记。  
```ruby
使用蒙特卡洛估值器估值积分(给定函数和域)。用逆方法生成格，并比较了不同PDF下的影响。
第二个PDF使用线性分布更接近f，采样频率更高，p更大，而然，f大/f大会降低其贡献，
但我们仍然获得了较快的收敛，因为f突出的部分是那些。  
```
从这一点来看，预测积分时格的分布本身是由PDF进行描述的。因此求解的目标积分区域也是如此。并且任何PDF偏好不改变积分本身(函数的输出)。  
再次强调，选择方向等格的样本必须也遵循给定的PDF，一方面，可以用PDF类直接生成类似的方向以保证一致性。  

使用什么样的PDF都可以得到积分的正确结果。而然，PDF的形状(字面意思)越接近f，则评估速度越快。因为我们更高频率地对f的重要区域(字面意思，fi较大)优先进行了采样，因此结果出现得更快。通常说法是，如此采样的方差更低(10-39)。  
#### 直接照明
从更高层次考虑设计总有助于理解你的渲染的正确性，目前求解的积分在做什么？以及对应您的目的是在物理上正确的吗？  

例如，您可能还记得有一个求解直接光照的积分形式，它仅对灯源区域进行采样，甚至仅求解此特定形状的积分。(阴影光线参与计算给定点的直接光照)。(使用普通的均匀PDF即可)。这是您在渲染中求解所有表面直接光照的直接方法。  

仅上述一例就可以说明问题(10-8)。  
如果我们求解的积分是半球(如漫反射材料正常做的那样)，首先，我们改变了积分的求解目的。其次，部分样本对于物理正确是无效的(即使我们在正确的样本中正确计算了带有阴影遮挡的光线)。无论采样频率如何(重要性采样)，黑色样本也被加入到积分中，该项的结果不是物理上正确的，因为现实中，偏转了光源的光线不会落入虚空，而是由光源更多发送光线到此方向上，即使它们没有在方向上直接相交。我们一开始就在错误的目的上计算。  

一旦理解此问题，本节的说明就相当具有本质的启发意义。当然，直接光照的积分本身就算一种效率极高的采样(对正确结果)。为了在半球积分实现类似的效果，应该改变BRDF的采样行为以更高频率指向灯光(将其视为某种材料)。这可能是同一事物的两种实现方式，两者都必须改变散射行为(因为确实偏转光线应该被导向光源，因为向其发送了更多光线)。但仍然可能有一些区别，直接光照的积分可以被更复杂的表达式表达(如下全局光照)，改变材料不一定具有此优势，还请读者注意。  

#### 光源建模(pbrt.12.2~5)
四种具体建模类型：点、方向、面、无限。  
对贡献最大的光源进行更多采样可以显著提高渲染效率。  

#### 多重重要性采样(Multiple Importance Sampling)
为了实现最佳光采样(减小物理设计偏差)，通常分析特定因子并导出一种抽样策略，如根据材料反射率，重要光源，或者只是一般的均匀环境光策略等等。  
若从每种技术策略抽取样本并最后平均的简单方式会引入方差，引入MIS是为了智能地分析更匹配形状的技术样本并为其正确分配配重，从而消除此类影响。首先，一般来说，多策略样本的估值器如下所述：  
```ruby
# 27
# https://www.pbr-book.org/4ed/Monte_Carlo_Integration/Improving_Efficiency#MultipleImportanceSampling
pn: pa pb...    # 多种分布的估值器
EST [ wa(dua)*fdua/pa(dua) + wb(dub)fdub/pb(dub) + ... ]
# 估值正确的配重函数条件是：Σw = 1 && if pn=0 then wn = 0

# 如前所述，设置均分的效果不好。
wn = 1/n_total

# MIS平衡启发式算法如下，其目的是使较为匹配的技术具有相对更大的配重
# balance heuristic
wn = pn(du) / Σa..j|pj(du)

# 对于两个策略的估值器
fdua / (pa(dua) + pb(dua)) +
fdub / (pa(dub) + pb(dub))
```
即使没有从所有分布中采样，也可以应用多重重要性采样。这种方法称为单样本模型。其中，`qn`是选择该策略的概率。对于单样本模型，平衡启发式被证明是最优的。  
```ruby
(wn(du)/qn) * (fdu/pndu)
```

**MIS补偿**。  

#### 环境采样(Environment Map Lights)
根据环境图亮度导出抽样策略。  
略；  

#### 分裂(splitting)
略；  

#### 多光随机采样(Many-Light Sampling, pbrt.12.6)
多光源的照明(辐射测量中的线性假设)类似于叠加，但无需真的分别进行采样累加，这将相当昂贵，  
可以随机选择一个光源，并按照光源贡献配重此样本。  
在均匀灯源采样概率下，概率质量函数(PMF)的值始终为1除以灯的数量。功率概率也很常见。实践中，要评估最近的重要光源，还需要为光对象建立空间数据结构。  

---
## 经典全局照明(Kajiya, 1986)
不同文献导致了这一算法真正理解上的困难。有时错误的渲染结果也难以发现。  

本质上，渲染方程解决了BSDF在半球环境照明的反射到眼睛(即所谓的`Lo`)的单次问题。  

基于路径追踪的，精确的全局照明方案更关注路径搜索的完全过程以及每个Li是如何具体定义了照明方式的形式。最终结论可能是没有明确结论。将照明和路径追踪的概念分开也许有利于得到对渲染的高级理解。  
路径追踪设想的理想照明是，Li是通过**光源**一路反射到达最终半球的。我们先假设这成立，以该方式说明方程，`Lo/Li`只是对路径上辐射度在两侧不同上下文的不同称呼。对于命中初始光源的`Lo`才有可能贡献整条路径，这类发光表面(照明器)的输出等于`Le`项或者根本没有，无需任何积分计算，因为实践中此次评估的`Lo`不考虑其反射积分，否则需要反复出现求解积分。而对于其他间接表面，大多不发光，也不包含`Le`项，只是传递初始光线的照明。  
因此，算法通常包含到达发现`Le`中止的必要条件，无论从递归还是迭代形式分析都可以得到类似的理解。迭代中，按照相机出发反向查询最方便，可令`Le/Lo/Li`的预计值由`1.0`预留占位，由于当最后被乘以`Li = Lo = Le`时，可以理解到只是延迟了`Li`需要未知值赋值的影响。  
~~上面这段话，可以验证通常做法与渲染方程的正确匹配性。以避免明显错误。~~  

再次提醒，我们没有明确下结论这就是解决问题通用的形式。用户可能使用物理上错误的方式进行追踪，因此仅在符合理想照明(必定命中光源)时使该方案变得有用。如直接光照一节说明。  

#### 未命中光源的错误照明
由于很难在有限时间内命中所谓的`Le`，导致每条路径的贡献都是狭小且奇怪的。这些(物理上错误)样本仍被记录！(和缝隙中的遮蔽样本相同的效果)  
如果场景中只有一个很小的灯具，大多数对象很难根据BRDF"最终"命中它，产生链式反应，由于所有表面都少接受照明，整体画面非常暗。  

这不符合现实，光源发送更多的光和频率，而且至少直接照亮整个正面，而不是让表面自己尝试命中它(否则是黑暗的)。  
你或许发现问题主要集中在漫射等材料随机散射的问题上，因为漫射材料在场景中的照明基本充当二次光源。  

真正的全局照明需要更好的抽象方式。本文我们的目的是分析这些问题的根本原因，以便理解各种方案的原理。  

#### 方法1(globillum.18、43)
首先，在每个散射点额外采样一次直接光的结果`dcol`，新建一个变量，持续在路径上累积`col += dcol * rad_li;`直到Li命中Le。  
这首先累计了该表面干净的直接光照，因为第一次`rad_li = 1.0`，随后间接光照通过完全一致的路径追踪开始捕获。  
你惊奇的发现，如果错过，它只是不产生更多间接光照，而不会导致非常错误的图像。  

但要注意，取消非漫射材料受到的直接光影响，因为在这一点上只是反射、折射，而不增加光。  
```cpp
col -= dcol * rad_li; // 取消直接贡献
```
<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/10-1.png">
    </div>
  </div>
  <p>图1：方法1[<a href="https://en.wikipedia.org/wiki/Global_illumination" title="">wikipedia</a>]</p>
</div>

这通过以下重新解释方程的方式表达：  
最终半球的直接照明在第一次就评估，而间接部分开始递归求解(并包含其直接部分)。该渲染方程(43)符合上述累积方程。  
```ruby
# treat Li as Lid Lii (Partitioning)
Lo = Le + ∫Lid + ∫Lii
```

##### Russian Roulette
俄罗斯轮盘赌概率性地终止光路，有助于减少计算量。  
基于概率`p`中止路径，存活的光路`1/(1-q)`缩放贡献。  
```cpp
float survivalProb = clamp(dcol.max(), 0.1, 1.0);
if (rand() > survivalProb) {
    break; // terminate path
}
dcol /= survivalProb; // scale to keep estimator unbiased
```
