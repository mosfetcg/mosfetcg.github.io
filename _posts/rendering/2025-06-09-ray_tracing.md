---
layout: page
title:  "光线追踪-过往明日"
author: mosfet
category: rendering
tags: 渲染 全局照明 路径追踪
---

<style>code:not(pre code) {color:green!important}</style>

## refs
```
cs348b: Image Synthesis Techniques

光线追踪 - lecture1,2
高级直接照明 - lectrue10,11
经典全局照明 - lectrue12, focg23

1✅ 如下
4,5,6,7✅ 无参考
10✅ 直接照明  如下
11✅ 直接照明2 如下
12✅ 全局照明  如下
```

## 光线追踪
最初与光线追踪相关的渲染算法可追溯到`Ray casting(Appel-1968)`：  
①每像素发出**一条**光线用于寻找对象。  
②在表面另向光源发出**一条**阴影光线检查照明贡献。  

现代术语中这两个过程的目的称为可见性和着色(照明和阴影模型)。由两条主要光线分别完成。这种算法也被划为图像顺序渲染类型，因其典型的迭代方式。  
几个如今熟悉的概念在这里已经存在或揭示，如shadowRay、光源、Scene Object，相机投射的光线称为view ray。现在我们可能习惯更明确的方式定义它们。  

下一个进展来自于`An improved Illumination
model for shaded display(Whitted-1979)`。  
追踪器的主要改动如下：  
①除了镜子或玻璃，否则总是向光源发送阴影光线。  
②为镜子或玻璃，递归生成新光线(反射或透射)。  
```cpp
// Ray Tracing
Whitted(ray) {
  L = 0; // 程序层面：顶级堆栈父级评估的表达式，有时需要开始递归调用求解未知量(重用条件分支)，有时结束并归还给上一级使其评估
  if hit_any {
    if glass_or_mirror               // 改变光线路径，不贡献光照
      return Whitted(_ray_);
    else if light_not_shadowed       // 若为普通表面，检查遮挡并计算光照 
      L += scatteredIllumination;    // 表示要将光线弹射到光源，可使用简单的直接照明计算，归还给上一级L并计入"总和"(如果存在弹射)
  }
  return L;
}
```
注意到，新说明的镜子和玻璃不计算光照而改变路径，命中普通对象会结束调用。在一系列路径上，会逐步传播最后的结果。  

现代光线追踪中，`路径追踪(path tracing)`被称为一种"Random Walk"，根据渲染方程，其累积值类似为以下程序：  
```cpp
// Path Tracing
PathTrace(ray) {
  L = 0;
  if hit_any {
    L += add_surface_emission;                       // 1
    L += reflection * PathTrace(Direction());        // 2
  }
  return L;
}
```
有趣之处在于路径追踪允许对各种不同材料的建模，使得第二步进一步与之前的方法以及实现方式区分开来，因为某些行为需要随机采样，这导致了对其"随机摸索"的某种描述。  
如果不是直接命中光源，通常Le仅在最后命中发光表面(并不是绝对事件)出现一次计入。另外，该代码的逻辑不完整，因为必须声明停止调用，通常遇到Le时，第二部分会被忽略并完成归还。该示例仅说明`L+=`的累积方式，因此，总和中的每个贡献量从光源到初始位置应呈现递减，除非反射率大于1。  

**布林法(Blinn's Law)**  
科技进步时，渲染时间不变。  
As technology advances, rendering time remains constant.  

## 高级直接照明
本节主要根据材料对渲染方程中的密度选择实践做了一些总结。  
我们可以为到来的随机样本分配不同配重而不再是均匀密度产生一些"强调内容"，有时这种强调是必要的，尤其是均匀生成采样以及均匀的效果不一定是物理上正确的，我们可以分析出新的密度函数并坚持使用简单的均匀产生样本程序，这称为重要性采样。  
例如，在一个简单的直接照明采样中，半球方向(任意)和锁定光源的面积方程你使用哪个？除非前者带有指向灯光的有效PDF，否则效果达不到后者的完美采样，因为每一次采样都直接有效(对于我们的目标)。注：或者使用方向采样时，只生成灯光线，但这违背了均匀生成的初衷，另外方向采样也有可能优于面积，它对球体正前方的采样空间更宽，效果也许更好。我们把这个问题留给读者思考。  

#### 环境纹理光源(Environment Map Lights)
用户很容易想要从环境光源(纹理图)当作光源，但最好根据亮度生成PDF进一步考虑问题，我们可能称之为环境光源的重要性采样。  
另外，一起使用环境和单独光源时，也需要注意实现上的区别，但这里并不是关注此问题。  

#### 多重重要性采样(MIS, Multiple Importance Sampling)
现在我们仍然只讨论直接光照采样的情况。  
Uniform Light Sampling 通常情况都不好！除非亮度相近且充满世界。例如天空。  
Light Importance Sampling 重要光源偏向。使其脱颖而出。  
BRDF Importance Sampling BRDF强度优先采样。这是自然的，因为采样那些有效视觉区域更好。  

我们也可以反过来思考这些问题，只在光源采样可能不匹配BRDF，只在BRDF采样可能不会命中光源。  
新MIS估值器的数学表示如下(27)：  
```ruby
∫ ~= 1/N[Σ(i=1..Na)w1g/p1 + Σ(i=1..Nb)w2g/p2 + ...]
```
上述每个子项规则代表独立的重要性采样方式，重要密度以及光线传输情况。  
一是完整抽取所有规则的样本，配重出单个效应样本加入贡献，计算上最终类似于原来的方程，全采样配重可根据以下启发式平衡，常数配重有点钝性。  
```ruby
# 样本计数
wI = pI / Σ(rules_j=1..m)(Nj/N)pj
```
这存在性能和追踪多条路径的实现成本，分离为单次路径也可以评估MIS。可以通过启发式配重概率选择规则，并将结果乘以它。  

#### 分裂积分器(Splitting)
略；  

#### 多光采样(Many-Light Sampling)
多光采样设计用于具有数百或数千盏灯的场景，在这些场景中，每个灯的采样在计算上都是昂贵的。  
即使您只随机选择一个光源，计算成本也来自选择在灯表面上选择有效点并确保准确照明的过程。为此有一些代替方法。  

---
## 经典全局照明(Kajiya, 1986)
不同文献导致了这一算法真正理解上的困难。有时错误的渲染结果也难以发现。  

本质上，渲染方程解决了BSDF在半球环境照明的反射到眼睛(即所谓的`Lo`)的单次问题。  

基于路径追踪的，精确的全局照明方案更关注路径搜索的完全过程以及每个Li是如何具体定义了照明方式的形式。最终结论可能是没有明确结论。将照明和路径追踪的概念分开也许有利于得到对渲染的高级理解。  
路径追踪设想的理想照明是，Li是通过**光源**一路反射到达最终半球的。我们先假设这成立，以该方式说明方程，`Lo/Li`只是对路径上辐射度在两侧不同上下文的不同称呼。对于命中初始光源的`Lo`才有可能贡献整条路径，这类发光表面(照明器)的输出等于`Le`项或者根本没有，无需任何积分计算，因为实践中此次评估的`Lo`不考虑其反射积分，否则需要反复出现求解积分。而对于其他间接表面，大多不发光，也不包含`Le`项，只是传递初始光线的照明。  
因此，算法通常包含到达发现`Le`中止的必要条件，无论从递归还是迭代形式分析都可以得到类似的理解。迭代中，按照相机出发反向查询最方便，可令`Le/Lo/Li`的预计值由`1.0`预留占位，由于当最后被乘以`Li = Lo = Le`时，可以理解到只是延迟了`Li`需要未知值赋值的影响。  
~~上面这段话，可以验证通常做法与渲染方程的正确匹配性。以避免明显错误。~~  

再次提醒，我们没有明确下结论这就是通用的形式。用户可能使用随意的追踪以及设置了最大固定次数上限并错过光源导致错误的渲染，因此仅在符合理想照明(必定命中光源)时使该方案变得有用。错过光源的追踪大多数是嘈杂且错误的。除非你不可能错过它们，或者理解了正确的采样方式。  

#### 未命中光源的嘈杂解释
由于很难在有限时间内命中所谓的`Le`，导致每条路径的贡献都是狭小且奇怪的。这些样本仍被记录！(和缝隙中的遮蔽样本相同的效果)  
如果场景中只有一个很小的灯具，大多数对象很难根据BRDF"最终"命中它，产生链式反应，由于所有表面都少接受照明，整体画面非常暗。  

这不符合现实，光源发送更多的光和频率，而且至少直接照亮整个正面，而不是让表面自己尝试命中它(否则是黑暗的)。  
你或许发现问题主要集中在漫射等材料随机散射的问题上，因为漫射材料在场景中的照明基本充当二次光源。  

真正的全局照明需要更好的抽象方式。本文我们的目的是分析这些问题的根本原因，以便理解各种方案的原理。  

#### 方法1(globillum.18、43)
首先，在每个散射点额外采样一次直接光的结果`dcol`，新建一个变量，持续在路径上累积`col += dcol * rad_li;`直到Li命中Le。  
这首先累计了该表面干净的直接光照，因为第一次`rad_li = 1.0`，随后间接光照通过完全一致的路径追踪开始捕获。  
你惊奇的发现，如果错过，它只是不产生更多间接光照，而不会导致非常错误的图像。  

但要注意，取消非漫射材料受到的直接光影响，因为在这一点上只是反射、折射，而不增加光。  
```cpp
col -= dcol * rad_li; // 取消直接贡献
```
<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/10-1.png">
    </div>
  </div>
  <p>图1：方法1结果[<a href="https://en.wikipedia.org/wiki/Global_illumination" title="">场景灵感来源</a>]</p>
</div>

这通过以下重新解释方程的方式表达：  
最终半球的直接照明在第一次就评估，而间接部分开始递归求解(并包含其直接部分)。该渲染方程(43)符合上述累积方程。  
```ruby
# treat Li as Lid Lii (Partitioning)
Lo = Le + ∫Lid + ∫Lii
```

##### Russian Roulette
俄罗斯轮盘赌概率性地终止光路，有助于减少计算量。  
基于概率`p`中止路径，存活的光路`1/(1-q)`缩放贡献。  
```cpp
float survivalProb = clamp(dcol.max(), 0.1, 1.0);
if (rand() > survivalProb) {
    break; // terminate path
}
dcol /= survivalProb; // scale to keep estimator unbiased
```
