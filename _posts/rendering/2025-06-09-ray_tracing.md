---
layout: page
title:  "光线追踪-过往明日"
author: mosfet
category: rendering
tags: 渲染 全局照明 路径追踪
---

<style>code:not(pre code) {color:green!important}</style>

## refs
```
cs348b: Image Synthesis Techniques

光线追踪 - lecture1,2
高级直接照明 - lectrue10,11
经典全局照明 - lectrue12, focg23

1✅ 如下
4,5,6,7✅ 无参考
10✅ 直接照明  如下
11✅ 直接照明2 如下
12✅ 全局照明  如下
```

## 光线追踪
最初与光线追踪相关的渲染算法可追溯到`Ray casting(Appel-1968)`：  
①每像素发出**一条**光线用于寻找对象。  
②在表面另向光源发出**一条**阴影光线检查照明贡献。  

现代术语中这两个过程的目的称为可见性和着色(照明和阴影模型)。由两条主要光线分别完成。这种算法也被划为图像顺序渲染类型，因其典型的迭代方式。  
几个如今熟悉的概念在这里已经存在或揭示，如shadowRay、光源、Scene Object，相机投射的光线称为view ray。现在我们可能习惯更明确的方式定义它们。  

下一个进展来自于`An improved Illumination
model for shaded display(Whitted-1979)`。  
追踪器的主要改动如下：  
①除了镜子或玻璃，否则总是向光源发送阴影光线。  
②为镜子或玻璃，递归生成新光线(反射或透射)。  
```cpp
// Ray Tracing
Whitted(ray) {
  L = 0; // 程序层面：顶级堆栈父级评估的表达式，有时需要开始递归调用求解未知量(重用条件分支)，有时结束并归还给上一级使其评估
  if hit_any {
    if glass_or_mirror               // 改变光线路径，不贡献光照
      return Whitted(_ray_);
    else if light_not_shadowed       // 若为普通表面，检查遮挡并计算光照 
      L += scatteredIllumination;    // 表示要将光线弹射到光源，可使用简单的直接照明计算，归还给上一级L并计入"总和"(如果存在弹射)
  }
  return L;
}
```
注意到，新说明的镜子和玻璃不计算光照而改变路径，命中普通对象会结束调用。在一系列路径上，会逐步传播最后的结果。  

现代光线追踪中，`路径追踪(path tracing)`被称为一种"Random Walk"，根据渲染方程，其累积值类似为以下程序：  
```cpp
// Path Tracing
PathTrace(ray) {
  L = 0;
  if hit_any {
    L += add_surface_emission;                       // 1
    L += reflection * PathTrace(Direction());        // 2
  }
  return L;
}
```
有趣之处在于路径追踪允许对各种不同材料的建模，使得第二步进一步与之前的方法以及实现方式区分开来，因为某些行为需要随机采样，这导致了对其"随机摸索"的某种描述。  
如果不是直接命中光源，通常Le仅在最后命中发光表面(并不是绝对事件)出现一次计入。另外，该代码的逻辑不完整，因为必须声明停止调用，通常遇到Le时，第二部分会被忽略并完成归还。该示例仅说明`L+=`的累积方式，因此，总和中的每个贡献量从光源到初始位置应呈现递减，除非反射率大于1。  

**布林法(Blinn's Law)**  
科技进步时，渲染时间不变。  
As technology advances, rendering time remains constant.  

## 高级直接照明
#### 非均匀蒙特卡洛估值
让我们回顾一下积分的估值器，需要生成按du~p分布的格，以准确求解积分`∫S|fdu = Σfdui/pdui`。  
使用什么样的PDF都可以得到积分的正确结果。而然，PDF的形状(字面意思)越接近f，则评估速度越快。因为我们更高频率地对f的重要区域(字面意思，fi较大)优先进行了采样，因此结果出现得更快。通常说法是，如此采样的方差更低(10-39)。  
#### 直接照明
从更高层次考虑设计总有助于理解你的渲染的正确性，目前求解的积分在做什么？以及对应您的目的是在物理上正确的吗？  

例如，您可能还记得有一个求解直接光照的积分形式，它仅对灯源区域进行采样，甚至仅求解此特定形状的积分。(阴影光线参与计算给定点的直接光照)。(使用普通的均匀PDF即可)。这是您在渲染中求解所有表面直接光照的直接方法。  

仅上述一例就可以说明问题(10-8)。  
如果我们求解的积分是半球(如漫反射材料正常做的那样)，首先，我们改变了积分的求解目的。其次，部分样本对于物理正确是无效的(即使我们在正确的样本中正确计算了带有阴影遮挡的光线)。无论采样频率如何(重要性采样)，黑色样本也被加入到积分中，该项的结果不是物理上正确的，因为现实中，偏转了光源的光线不会落入虚空，而是由光源更多发送光线到此方向上，即使它们没有在方向上直接相交。我们一开始就在错误的目的上计算。  

一旦理解此问题，本节的说明就相当具有本质的启发意义。当然，直接光照的积分本身就算一种效率极高的采样(对正确结果)。为了在半球积分实现类似的效果，应该改变BRDF的采样行为以更高频率指向灯光(将其视为某种材料)。这可能是同一事物的两种实现方式，两者都必须改变散射行为(因为确实偏转光线应该被导向光源，因为向其发送了更多光线)。但仍然可能有一些区别，直接光照的积分可以被更复杂的表达式表达(如下全局光照)，改变材料不一定具有此优势，还请读者注意。  

#### 环境纹理光源(Environment Map Lights)
接下来会介绍几种常见直接光照的IS优化。  

用户很容易想要将环境光源(纹理图)设置为光源，最好根据其亮度分布进行重要性采样，即亮区域的照明效果更快展现。  
另外，当场景共同使用环境和单独光源时，也需要注意实现上的区别，但这里并不是关注此问题。  

#### 重要性采样+(MIS, Multiple Importance Sampling)
有几种常见采样模式：  
第一是均匀环境光采样，如前所述，对单一光源这种采样总是造成整体的低亮度结果。物理上通常不正确的，除非亮度相近且充满世界。但有时也被作为一个有效样本进行参考。  
第二是直接光采样，如前所述(可选IS)。  
第三称为BRDF IS，这是自然的，因为采样那些有效反射区域的光更好。  

将多种样本的结果平均即得MIS。  
我们也可以互相思考这些问题，只在光源采样可能不匹配BRDF(产生物理误差?因为其反应没这么大！)，只在BRDF采样可能不会命中光源。这些都是问题。  
新MIS估值器的数学表示如下(27)：  
```ruby
∫fdx ~= 1/N [Σ(i=1..Nn)wn*f(xn,i)/pn(xn,i)]  # xn,i 第n种样本在i的样本
```
下面存疑(28)。需要验证。  
上述每个子项规则代表独立的重要性采样方式，重要密度以及光线传输情况。  
一是完整抽取所有规则的样本，配重出单个效应样本加入贡献，计算上最终类似于原来的方程，全采样配重可根据以下启发式平衡，常数配重有点钝性。  
```ruby
# 样本计数
wI = pI / Σ(rules_j=1..m)(Nj/N)pj
```
这存在性能和追踪多条路径的实现成本，分离为单次路径也可以评估MIS。可以通过启发式配重概率选择规则，并将结果乘以它。  

#### 分裂积分器(Splitting)
略；  

#### 多光采样(Many-Light Sampling)
多光采样设计用于具有数百或数千盏灯的场景，在这些场景中，每个灯的采样在计算上都是昂贵的。  
即使您只随机选择一个光源，计算成本也来自选择在灯表面上选择有效点并确保准确照明的过程。为此有一些代替方法。  

---
## 经典全局照明(Kajiya, 1986)
不同文献导致了这一算法真正理解上的困难。有时错误的渲染结果也难以发现。  

本质上，渲染方程解决了BSDF在半球环境照明的反射到眼睛(即所谓的`Lo`)的单次问题。  

基于路径追踪的，精确的全局照明方案更关注路径搜索的完全过程以及每个Li是如何具体定义了照明方式的形式。最终结论可能是没有明确结论。将照明和路径追踪的概念分开也许有利于得到对渲染的高级理解。  
路径追踪设想的理想照明是，Li是通过**光源**一路反射到达最终半球的。我们先假设这成立，以该方式说明方程，`Lo/Li`只是对路径上辐射度在两侧不同上下文的不同称呼。对于命中初始光源的`Lo`才有可能贡献整条路径，这类发光表面(照明器)的输出等于`Le`项或者根本没有，无需任何积分计算，因为实践中此次评估的`Lo`不考虑其反射积分，否则需要反复出现求解积分。而对于其他间接表面，大多不发光，也不包含`Le`项，只是传递初始光线的照明。  
因此，算法通常包含到达发现`Le`中止的必要条件，无论从递归还是迭代形式分析都可以得到类似的理解。迭代中，按照相机出发反向查询最方便，可令`Le/Lo/Li`的预计值由`1.0`预留占位，由于当最后被乘以`Li = Lo = Le`时，可以理解到只是延迟了`Li`需要未知值赋值的影响。  
~~上面这段话，可以验证通常做法与渲染方程的正确匹配性。以避免明显错误。~~  

再次提醒，我们没有明确下结论这就是解决问题通用的形式。用户可能使用物理上错误的方式进行追踪，因此仅在符合理想照明(必定命中光源)时使该方案变得有用。如直接光照一节说明。  

#### 未命中光源的错误照明
由于很难在有限时间内命中所谓的`Le`，导致每条路径的贡献都是狭小且奇怪的。这些(物理上错误)样本仍被记录！(和缝隙中的遮蔽样本相同的效果)  
如果场景中只有一个很小的灯具，大多数对象很难根据BRDF"最终"命中它，产生链式反应，由于所有表面都少接受照明，整体画面非常暗。  

这不符合现实，光源发送更多的光和频率，而且至少直接照亮整个正面，而不是让表面自己尝试命中它(否则是黑暗的)。  
你或许发现问题主要集中在漫射等材料随机散射的问题上，因为漫射材料在场景中的照明基本充当二次光源。  

真正的全局照明需要更好的抽象方式。本文我们的目的是分析这些问题的根本原因，以便理解各种方案的原理。  

#### 方法1(globillum.18、43)
首先，在每个散射点额外采样一次直接光的结果`dcol`，新建一个变量，持续在路径上累积`col += dcol * rad_li;`直到Li命中Le。  
这首先累计了该表面干净的直接光照，因为第一次`rad_li = 1.0`，随后间接光照通过完全一致的路径追踪开始捕获。  
你惊奇的发现，如果错过，它只是不产生更多间接光照，而不会导致非常错误的图像。  

但要注意，取消非漫射材料受到的直接光影响，因为在这一点上只是反射、折射，而不增加光。  
```cpp
col -= dcol * rad_li; // 取消直接贡献
```
<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/10-1.png">
    </div>
  </div>
  <p>图1：方法1[<a href="https://en.wikipedia.org/wiki/Global_illumination" title="">wikipedia</a>]</p>
</div>

这通过以下重新解释方程的方式表达：  
最终半球的直接照明在第一次就评估，而间接部分开始递归求解(并包含其直接部分)。该渲染方程(43)符合上述累积方程。  
```ruby
# treat Li as Lid Lii (Partitioning)
Lo = Le + ∫Lid + ∫Lii
```

##### Russian Roulette
俄罗斯轮盘赌概率性地终止光路，有助于减少计算量。  
基于概率`p`中止路径，存活的光路`1/(1-q)`缩放贡献。  
```cpp
float survivalProb = clamp(dcol.max(), 0.1, 1.0);
if (rand() > survivalProb) {
    break; // terminate path
}
dcol /= survivalProb; // scale to keep estimator unbiased
```
