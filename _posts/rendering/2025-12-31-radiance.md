---
layout: page
title:  "base"
author: mosfet
category: rendering
tags: 
published: true
---

<!-- ## `#830465`  -->
<style>code{color:#830465;font-weight: bold}nav a{color:#830465!important}</style>
<!-- hide this post  -->

---
### 14. 积分
#### 1. 测量论
**格和域测量**  
考虑积分`∫(f=1)*dA`的每个组件是什么？它既可以表示曲面(z=1)下的微小体积块，也可以表示域微面`dA = dxdy`本身，关键就在于要不要解释可选的高度。  
对于后者，因此这种积分表达了积分操作域的求和，即`ΣdA`。  
该积分称为测量函数，`μ`称为**测量基本格**。这种方法可以描述给定域的度量。  
```ruby
DOMAIN_AREA(S) =∫S|dμ -> value    # R+
#          DomainSet/Space
```
图形学中有许多**数值近似**积分的方法，并且经常使用！无需投入微积分分析技巧，即可求解此类测量。  
可举此一例说明**采样**的概念，通过采样"格"即可评估积分。请在某处选择适当大小的格`dμ(i)`，获取和分析积分中`f(dμi)`的值是可选的(具体关系请见下解释)，取决于做什么。例如，仅完整测量积分域仅需`f(dμ) = 1`，相加格即完成测量。  

**配重(weighted)函数**  
对于一个域`S`的测量，可在积分中加入一个非负配重函数来产生新的测量。这是：  
```ruby
∫S|f dA
```
数学上还是一个普通的积分，从技术上讲，这也不改变任何积分的功能，并且只是由于在本文的上下文中新建的术语。  
配重是本文中才第一次出现的数学术语，尚不清楚它应该被归属于哪个领域，可能是概率论。  
这个产生新的测量的"配重"，意味着每个格可能或多或少变得更重要，值更大，或更小。一种基本因子。或者……？  

**测量函数平均值**  
观察下面这两个积分的比率。  
```ruby
average(f or f(x)) = ∫S f(dμ)dμ
                     ----------- = f(dμ1)+f(dμ2)... / 1+1+1
                     ∫S 1dμ
```
该比率解释了一种纯微积分式计算函数平均值的基本方法，这相当于通过格逐步进行完整测量，积分比率为函数总值(Σfdu)和域总值(Σ1du)，这很容易理解。由于`dμ`被消去，这是无关的。采样格时，我们同时评估函数，当然因为这是它的域。  

#### 2. 随机量、PDF和随机值期望 
许多图形算法使用概率来构造随机样本来解决积分和平均问题。与测量论有基本联系。  

有时很难具体地说清楚”随机量”的行为是什么，但请看渲染方程。一方面指的是”格”对应的函数结果，一旦选定格，则结果确定，这两个本身就具有函数关系。而然对结果进行分布分析可能有点抽象，因为可能是颜色等数据，简单而言，每个互斥的域(即格的选项)更容易表示。  
选定特定格的机会通常以相对**密度**比较，该密度是一个**相对值**，较小仅概念上表达相对更小。  
容易通过一维的例子理解这一点。  
如果假设所有格的概率总和为标准化1，那么反过来一个格的概率是多少？也许存在一个曲线函数`p(du)du`可以解释这一点，密度是一种神奇的符号，只要具有度量就可以转换为另一种值(格是具有度量的)，这里将格转为实际概率。因此此类积分转换为区域概率。这些曲线就是`概率密度函数(probability density function)`**x~`p`**，密度在这里代表单位概率累积的速率，我们先不用考虑如何正确映射密度的实际数值。  
```ruby
prob   = du * p(du)

prob|S = ∫S|p(du)du
p(du) >= 0
∫INF| p(du)du = 1 # 概率之和为1(各种事件)
```
应该明白，有一个简单的方式计算均匀密度的实际值，那就是1/domain，因为单位概率面积的总定值不变(否则就不能称为PDF)，越宽，则该常量也越小。  
其次，任何积分为1的曲线都可以作为PDF。  

第二个概念是x~p的`预期/期望值(expected value)`。另外，x通常作为**函数结果**解释，而不是格的解释，但后两项可以作为格解释。  
由于我们已经解释了后面两项就是概率，因此该表达式只是采样结果值 * 某种概率。既然你知道根据概率缩放的值，无论划分宽度多少，这些总和代表什么？为什么代表期望？  
```ruby
E(x) = ∫x*p(du)du         # but why?
```
下面来看这个：如果我们将单位概率转为实际足够样本的比例，期望本质上应该由以下式给出：  
```ruby
1000 x1 + 2000 x2 + ...   # half prob respectively
  /  3000                 # 记住我们可以单位化样本数量，coefficients为概率，并且总次数变为/1.0
= 0.33x1 + 0.66x2 / 1
= x1+2x2 / 3              # 无论数量如何，都应该代表相同过程和结果，即f的平均值

# rewrite with normaliztion
# thats our E(x)!
(p)(x1+x2) / 1
#pxdx   x
```
这样应该令人信服，概率确实在期望中起到作用，(式1)也表示理论上的参与度，在所有事件中这些值的参与贡献不同。  
所谓的估值器只是持续记录上述过程f采样后的平均值(如3000个样本)。你当然需要小心遵循相同的概率来产生样本，否则与贡献地图将不匹配。  
有兴趣的读者可以研究一下下项的`1`和比率方法有无联系。  

```ruby
E(v1+v2) = Ev1 + Ev2    # ①平均值应该相等
E(av)    = aE(v)        # ②常数不影响
E(Σfi)   = ΣE(fi)       # "样本和的期望"等于每个样本期望之和  注意不是样本的期望
                        # 这可以用①来证明  
```
无论变量是否独立，这种线性属性都成立。此求和属性对于大多数蒙特卡洛应用至关重要。  

#### 3. 方差(variance暂译)(略)

#### 4. 估值(estimator)
尽管这些focg的材料可能是正确的表述。目前应该将IST作为引用。  
```ruby
# 5-45
         I(f) = ∫S|f(du)du
         E(f) = ∫S|f(du)p(du)du          # 证明如前所述
    dui~p, fi = f(dui)                   # SAMPLES : dui -> fi，尾缀i表示一个样本
      EST(fi) = 1/N * Σ(i=1..N)fi.       # 事实，所有按i~p产生的样本的均值近似于期望
  #estimator 这里的参数指的是求和项

# 可改写为
E(f) = ∫S|[g=fp]du ~= EST(g / pdu)
```
首先，估计中iid样本的必要条件是PDF`vari~p`，两式相等正确的原因在于假设样本已遵循此分布，否则，就不是同一个期望值。我们已经在上面证明了这一点。  
该术语指的是`独立同分布-independent identically distributed(iid)`。  
可以肯定的是，我们必须让`N = INF`。这种信心由大数法(Law of Large Numbers)表达。  

*持平(unbiased)*  
```ruby
# 5-46
E(ESTfi) = E[1/N * Σfi]
         = 1/N E[Σfi]
         = ... ΣE(fi)
         = ... ΣE[f(dui)]  # 该样本来自于评估函数，替换
         = ... Σ∫
if p = 1 && S = 0..1, = I(f)|S
```
`蒙特卡洛`形式。评估一个f的积分的时候，估值器表达式为`fdui / pdui`，我们可以无偏求解该积分。  
```ruby
EST(fdui/pdui) = ? = 1/N* Σ(fdui / pdui)
E(↑) = ∫S|fdx              # prove: 5-47
```

为了获得良好的估计，我们需要尽可能多的样本，并且希望g/p具有较低的方差（g和p应该具有相似的形状）。  
智能地选择p称为`重要性采样(importance sampling)`，因为如果p和g同时在个某些地方很大，那么重要区域会有更多的样本。  

方程还显示了蒙特卡洛积分的基本问题：收益递减。由于估计的方差与`1/N`成正比，因此标准差与`1/√N`成正比。由于估计中的误差与标准差的行为类似，因此我们需要将N乘以四倍才能将误差减半。  
减少方差的另一种方法是积分的域S划分为几个较小的域Si，并将积分评估为Si上的积分之和。即抖动采样/分层采样。  
结果表明，分层抽样通常比重要性采样远远优越。  

#### 5. 略(14.4)

---
#### 18. 光
光是一类电磁辐射(能量的传播)，测量通常称为`辐射测量学(radiometry)`。  
我们从能量本身开始，能量单位`焦耳-J`。  
光子具有位置、传播方向和波长`λ(nm)`。光子的速度只取决于传播介质的折射率`c ~ n`。有时频率`f = c/λ`也用于光。这很方便，与λ和c不同，当光子折射到新介质中时，f不会改变。另一个**不变的**是光子携带的能量`q`，由以下关系给出：
```ruby
q = hf = hc/λ
```
`h`普朗克常数(J)。  

**光谱能量**  
对大量光子的能量`pi`求和可以计算总能量`Q`。  
我们可以画出波长间隔内感兴趣的能量分布，例如`q{λ500..600} = 10.2J`。划分越小越详细，我们可以进一步比较不同桶里的能量。  
而然通常的做法是将结果`Δq`(并且依赖于选定波长)除以该波长范围`Δλ`，因此得到一个称为`光谱能量(spectral energy)`的量`Qλ(下标) = Δq/Δλ`。如果这样做，即使在`dλ`减小到比`1nm`小时，感知的量会扩大。例如，此例为`Qλ{500..600} = 0.12J /nm`，尽管取的`dλ`较大，但在较小时仍然具有良好比较效果。  

注意，光谱能量是所谓的`密集量(intensive quantity)`，而不是能量、长度或质量等广延量。密集量可以被认为是密度函数，它告诉无限小点处的广泛量的密度(能量密度)，它不会说该波长的能量`Q = 0`，而是局部测量的一个有意义的量，不至于将光子由波长过滤到无法通过任何光子。  

我们将遵循图形惯例，几乎总是使用光谱能量，而很少使用能量。正确符号带有下标，相反，我们将去掉下标并使用Q来表示光谱能量。

**光谱功率**  
我们需要估计光源的能量持续恒定发送量。该速率即功率。  
单位瓦特，焦耳每秒。100瓦灯泡每秒消耗大约100J的能量。100W的光在一秒钟内产生惊人的1e20个光子。  

`光谱功率(spectral power)`的符号是`Φ(λ)`。计算方式为`Φ=Δq/(ΔtΔλ)`。  
由于我们使用光谱能量再除以时间，功率会均匀平摊到波长上，在较大范围上的结果会比一般的功率更小。  
因为单位是`W(nm)^-1`(瓦每纳米)。  

**辐照度**  
很显然，我们对照射到特定面积上`ΔA`的功率感兴趣。如果问"入射到一点上的功率？当然，"答案是"无"，我们必须观测比极小点稍微大点的东西，即一块小微面，就像我们之前那样做的一样(而不是观测真的波长的夹缝)。但是我们可以确实可以用它来近似为图形中这表面一点的功率。  
这称为`辐照度(irradiance)`。辐照度就是单位面积的功率`ΔΦ/ΔA`，展开为`H = Δq / ΔA*ΔtΔλ`。  
因此，单位是`J/m^2/s/nm`。同时使用纳米和米是因为这些是面积和可见光的自然单位。  

当光**离开表面**时，例如，当它被反射时，与辐照度相同的量称为`出辐照度/出射辐照度(radiant exitance)，E`。对入射光和出射(exitant)光使用不同的词很有用，因为同一点(ΔA)可能具有不同的辐照度和出辐照度。  

**立体角**  
下一个单位需要引入**立体角(solid angle)**`σ`的概念。它是角度概念的延伸。其扩展方式类似于将角度转为弧制(角度 -> 单位圆曲线长度量)的过程。您可以将其视为函数。  
类似地，一个立体角所得到的"弧制"，制式称为`球面度(steradians)`，最大值为`4Pi`。它是单位球体中的立体角向其表面以锥体投影所交的球壳表面积。  
特别小的立体角可视为方向向量，与上述的点辐照度一起使用很方便。  

**辐射度**  
`辐射度(radiance)`将辐照度给出的点表面功率进一步与各个**方向**联系起来，或者说它必须限制为上更小立体角`Δσ`方向上的量。  
这种更小范围的精确测量可以通过以下抽象仪器表达。我们选择圆形面积的`ΔA`作为被测量的辐照度点，使用匹配的立体角的圆锥罩限制光线范围，立体角本身不可见，而是让`ΔA`作为其前方的截面。  
``` ruby
     radiance
    \  Δσ  /cone_filter of H
     \    / H1
   H3 \  /
  H4  /--\ H2
      \--/ΔA
        .σ
```
因此测量结果是：`ΔH/Δσ = Δq/ Δσ* ΔAΔtΔλ`。  

这就是光谱辐射度，记住我们对所有术语省略了光谱一词。
辐射度这个量通常在程序中使用，因为我们可以将他设置成经典着色的半球表面结构上进行参考。  

首先，辐射度的一个奇妙特性是**它不会沿空间线变化**。我们假设点确实具有面积，越近则面积越大，越远则观测面积越小，这一本质导致了这个量始终不变。  
第二，该仪器的`ΔA`并不会与相同大小的表面直接重合，相反，必须将它扣在表面进行倾斜。很容易检查这一点，如果延长对`ΔA`照射，被测表面的实际面积更大，而不是等于它。该问题通过**余弦校正**解决。如果您想起了朗伯那就太好了。  
```ruby
   θ  / v/        #本文使用θ角度表示差异
   n /ΔA/
----?------ same? # => ΔA/cosθ
```
为了区分点上入射和射出的辐射度，则我们分别定义(离开表面)`Lo出射辐射度(surface radiance)`和(入射表面)`Li入射辐射度(field radiance)`。我们注意两者都需要余弦项。  
```
Lo =ΔE/Δσcosθ && Li =ΔH/Δσcosθ
```

**积分起来**  
一个例子是从出射辐射度导出其他量。因为辐射度是最小的辐射计量。  
```
Hi(p) = ∫all-rayin| Licosθ dσ
                      #矫正项 每条半球光线
# 为了不用特别分辨H、E我们直接加上i,o等表示出入符号，实际上原本的符号有点诡异
```
```ruby
      in in in
       \|/
-------.H-------
```
假设所有入射光线的Li恒定，我们不想直接在球面上积分球面度，因此我们转入它们的二维等效形式`dσ -> sinθ dθdφ`。(它们的球极位系角(a,b))。本质上都是在半球上拾取方向。  
```ruby
H = ∫半球|...dσ
  = ∫∫(θ,φ)|| Licosθsinθ dθdφ
  = PiLi
```
这种关系向我们展示了常数Pi的首次出现。这些因子在辐射测量中经常出现，并且是我们选择测量立体角的方式的产物。  

类似地，表面(而不是点)的功率是积分：  
```ruby
Φ = ∫S | H(p)dA
```
我们没有针对输入功率和输出功率的特殊术语或符号。这种区别似乎还不足以鼓励这种区别。

---
#### BRDF和传输方程
观察中，表面具有特征化的反射分布方式以传播辐射，对于任何方向的入射光，将一定比率的能量向各个方向出射。某种程度上，此分数应随入射和出射方向vi和vo变化。  
有一些测量方式可以检查这种关系，此`反射率(reflectance)`读数为`ρ = Lo/Hi`。该`Hi`是光源一点上的辐照度，如果对所有方向进行这样的测量，最终得到分布函数，称为`双向反射率分布函数(bidirectional reflectance distribution function)(BRDF)`。BRDF是我们仅需要知道的一切，以表征表面如何反射光的方向性。  

*方向半球反射率(501)*  
给定BRDF，很容易询问多少入射光被反射了，但该反射率通常只在单个入射方向讨论。这称为`方向半球反射率(directional hemispherical reflectance)`。  
`R(i) = power_in_all_vo / power_in_a_vi`；由于能量守恒，该量介于单位1之间。  
```ruby
R(i)=∫半球出射vo| ρ(i,o)cosθvo dvo    # 证明，略  
R(i)=∫半球出射vo| Ccosθvo dvo = PiC   # 略，简化为二重积分(见上)
```
朗伯BRDF描述了一种理想漫射表面，这种表面对于任何角度使用常数项`ρ(i,o) = C`。  
若理想朗伯存在`R = 1`的完全反射，因此得到假设常数实际为`ρ = 1/Pi`。若`R(i) = self.albedo`，则`ρ = self.albedo / Pi`；  

**传输方程(Transport Equation)**  
```ruby
Lo(vo)=∫半球入射vi| ρ(i,o) Li(vi)cosθvi dvi
                   #BRDF      # 每条半球入射光线的矫正
```
这通常称为计算机图形中的`渲染方程(1986)(rendering equation)`。  

另一种方程(18.2)形式采样空间中一块面积，而不是立体角。  
```ruby
dvi = (cosθarea/r²)dA # r距离
#===================== 
 --.dA-- 
 r/  n\θarea
 /  n\
-.dvi-cosθ1 #local
```
```ruby
Lo(p,vo)=∫area| ρ(i,o)Licosθ1 (cosθarea/r²)dA
V(p_local, p_area) = 1/0
```
当采样面积被遮挡时(如采样光源面积)，需要增加阴影光线判定函数`V(ray)`到积分中。检查其贡献是否为`0`。  

**光度/光子测量学(`photometry`)**  
对于每个光谱辐射量，都有一个相关的**光度测量量**，用于测量该量有多少对人类观察者有用。  

---
#### 23. 全局光照
如前所述，`路径追踪(path tracing)`通常是全局光照问题的直接解决参考文献之一。  
我们先解释渲染方程的具体求解方法以及进一步明确利用辐射度的正确性。  

```ruby
Lo(vo)=∫半球入射vi| ρ(i,o) Li(vi)cosθvi dvi  # 渲染方程
```
我们想要的是表面朝着给定方向的出射辐射度，例如正好反射到眼睛里的光线。  
那么这个值最后应该是多少？我们希望的是看见该光线的期望值(越来越稳定)。这可以通过查询右侧积分的期望值来计算，并且利用均值蒙特卡洛方法的样本和来平均。  
```ruby
∫S|g(x)dμ ~= 1/N [Σ(i=1..N)g(xi)/p(xi)]  # 蒙特卡洛积分


∫S|g(x)dμ -> ∫半球vi|ρ(i,o)Li(vi)cosθvidvi
#              vi{S}      g(vi)       dvi
           ~= 1/N[Σ(i=1..N)gvi/pvi]
```
检查g(vi)中的Li(vi)项，这些光线本身的辐射度从哪里来呢？别忘了我们从递归或循环中散射光线，因此它最终是可以被评估的，并最终来自于任意光源！  
另外，我们假定使用RGB颜色作为辐射度的直接映射。  

朗伯的BRDF`ρ = self.albedo / Pi`是一个均匀分配后的常数，建议使用`p(vi) = cosθvi / Pi`作为采样密度(这是对朗伯分布密度的推导)。(可见密度混合)。渲染方程抵消余弦和Pi常数变为：  
```ruby
g/p = self.albedo Li(vi)
```

**更完整的渲染方程(full transport equation)**  
(23.2)包含一个发光项，称为emmit。明确此形式的主要原因在于编程模型，发光项仅在光源提供，如天空和灯具返回其的固定值(并结束任何进一步的追踪)以提供给其他表面接受的`Li`，当然大多表面不会增加自发光量。  
```ruby
Lo(vo) = ∫ + emmit(vo)
```

**高级**  
只是轻易计算默认的渲染方程很容易导致弱照明场景的错误，需要采用其他策略进行优化。请见外部(已转移)。  

**准确的直接照明(23.3)**  
比起应用传统的直接光照模型，使用部分路径追踪技术可以捕获更基于物理的直接光照结果。  
通过求解面积形式的渲染方程，并对光源面积采样，可以产生漂亮的阴影和直接照明结果。这与优化方式中采样直接照明的过程相同。    

样本、描述样本的密度必须围绕灯具上的随机点展开。可以均匀随机选择灯具表面上一点，蒙特卡洛密度为`p = 1 / A`。  
```ruby
Lo(p,vo) ~= g/p
```