---
layout: page
title:  "数学薄记"
author: mosfet
category: miscellaneous
tags: 数学 微积分
---

---
# Ⅰ.微积分
一些高级内容，以防我忘了。  

## 梯度下降
这里补全了基础中列出的梯度下降方法以及图形中未提供的证明的一些有用信息。  

回想一下，梯度编码了每个轴的固定速率信息，看上去是一个向量。对于评估任意方向上的实际速率(纯量)由方向速率给出。根据速率的通用含义，我们表达差分差异量很容易。  
本质上这就是方向微斜度的基本作用，但我们再次提示这是：  
```ruby
f(p+v*t) ~= f(p) + ▽vf*t   #2D中，可视为绕一圈
```

下例中，打算通过梯度方向下降移动到达根，注意正梯度方向无解，因此反转(速率含义仍然成立)。可以评估方程：  
```ruby
0  =  f(ro)+▽vf*t    # f: r3->r1
   =  f(ro)+ kt      # 选择梯度方向
 t = -f(ro)/k
```

梯度下降算法数值估计函数的较低值位置，仅需要函数的输出。  
我们遵循梯度的负值，从而朝着最陡峭的下降方向前进。  
```ruby
ro - t▽(ro) # t>0  ▽从数值计算
```

## 表面积积分
参数化曲面对应的表面积可由积分方法`表面积积分(surface area integrals)`获得，如下：  
```ruby
f: ts->p

∫∫T|length(df/dt(p) × df/ds(p)) dtds
#para domain
```
每个微型矩形块`dtds`映射后，粘贴的方块曲率可被忽略，因此可能是两端不同速率(见触线)的平行四边形。只需要计算这两个区域之间的关系。  
```ruby
# x从左下角开始，计算平行四边形的边；因此通过向量的面积为|aXb|
a = df/dt(x)*dt
b = df/ds(x)*ds
```

## 曲面积分
当认为要为每个小块分配密度等量时，只需要乘以该密度函数，我们将表面积积分改为二重积分形式，找出速率面积(同样使用部分微斜度的交叉积)，然后通过高度(密度等)乘以面积来统计所有密度。这称为`曲面积分(surface integrals)`。  
通俗的讲，原本域的比率只是平行四边形的变形，现在还要加上函数分配。  
```ruby
∫∫R|f(p)length(df/dt(p)Xdf/ds(p)) dμ=dtds
```

## 通量
`通量(flux)`测量一3D表面流经多少流体(how much fluid is flowing through)的总速率。  
在积分的每个区域`dμ`中，该速率场的大小影响单位时间内粒子移动的数量，但很难说如果速率为0就没有流体在它上面，该乘积仅说明进入或离开。  
检查每个二重积分小项目的抽象结果，`dμ(如dA) * speed`对应几何上流动的流体体积，根据体积公式，应当乘以垂直高度而不是F斜边本身，因此通过`n`修正。另外，如果假设为水的密度，那么该值也同样可进一步计算质量。  
最后我们已假设这些全部都在单位时间内发生，通过积分来熟悉整个表面的总和，以将表达式右侧定义为整体的水质量变化，这确实告诉我们有多少水进入或退出表面。  
```ruby
∫∫surface| F(p)·n(p) dμ =  -dR/dt
         #速率场            质量 时间
```
当考虑参数曲面的通量问题时，我们不能取消曲面积分或表面积分面积块的变换的考虑，因此应该将cross项写入通量积分。并且`n`和`length()`的部分会被互相抵消。  

---
# Ⅱ. 向量
## 向量角度形式
```ruby
(3)Magnitude & direction    -> ||v||, angle
```
注意到之前对此形式解释的空白。尽管如此，不会对大多数内容造成影响。  
在这种表示中，向量`v`由其长度`len`以及与`x`轴**正**方向的夹角`C`一起给出。换句话说，总是使用三点钟开始的逆时针角度。  
```ruby
arctan = tan^-1(y/x) = C  # 函数arctan返回值为-0.5pi..0.5pi
# 当v不在Q1，也可以根据v构造包含绝对值的直角三角形，再根据此角度二次计算正确角度即可

# 快捷计算策略
Quadrant(象限) tan^-1(b/a)
Q1            -
Q2            +180
Q3            +180
Q4            +360
```
再次检查此结构，当长度和角度已知时，由于正交分量可由正余弦表示`[xy]`，表明形式之间能**互相转换**；  
```ruby
x = len(v)cosC, y = len(v)sinC
```
对角度形式进行相加时，不妨先转为第一形式。  

### 交叉积？
无论是哪种向量运算，一开始告诉我们的都是其计算定义，恰好存在相关包含该定义的等式以揭示其他意义，皆被证明。  
有关交叉积的一个事实是，基本所有图形学、数学资料都仅同意或愿意说明交叉积R^3的通常定义。  
它从根本上与3D空间相关，因为结果是存在于两个原始向量定义的平面"之外"的另一个向量。  

另一二维向量的类似物有时被称为`wedge product`，记为`X², XX(本文)`，输出一个纯量结果。  
这个从未介绍的所谓2D交叉积在术语上很容易被混淆，最好将其视为单独的概念，特别是有时也被错误、粗略地直接称为交叉积。我们应该避免这种滥用和误解。  
在R^2中，当然没有朝着第三方向的向量，因此没有真正符合传统定义概念的结果。  
```ruby
aXXb = a1b2-a2b1
```
尽管当前讨论的空间不存在第三轴，该纯量等于"潜在"正交向量的`z`符号值。  
```ruby
aXb  = [0 0 a1b2-a2b1]
```
以下代替表达式仍然成立。但注意区别，无需将结果再计算长度，但需要对`z`取绝对值。  
```ruby
|XX| = len(a)len(b)sinC
# 证明略，使用dot转换sin
```
进一步地，`abs(z)`也等于平行四边形面积。  
**正交(orthogonality/perpendicularity)测试**  
平行于`aXXb = 0 = ...sin(0)`。正交于`z = len(a)len(b)`时。  
**朝向(orientation)测试**  
以`a`为参考(表达式第一个变量的向量)，则：  
```ruby
>0  b在a的逆时针侧 (CCW)
<0  b在a的顺时针侧 (CW)
```
右手手掌指向A，弯曲四指指向B，若拇指指向自己，则意味B偏A的逆时针(CCW)。符号为正。反之亦然。  

我们还给出：  
```ruby
sinC²+cosC²=1  = (aXXb)²+(a·b)²=len(a)²len(b)²
```

## 正交方向向量的斜度关系
```ruby
v1[x1y1] v2[x2y2]
dot(v1,v2) = 0 = x1x2+y1y2;
                 x1x2  = -y1y2
                 x2/y2 = -y1/x1  # 斜度互为反倒数
```

## 一般计算
```ruby
# dist from point to line
solved by proj and line expression(all points are known)

# perp point from point to line
solved by proj and line expression(all points are known)
```

---
# Ⅲ. 变换
## 变换的概念
刻意将解释和抽象分离有助于容易重新组织高明的解释。因为通常情况下，解释部分一开始不一定最佳。  

**RECALL:** 回顾一下之前的术语，帧由一组测量和原点构成。向量表达特定帧下的测量量编码。  
*一个变换将一组测量a(以及其测量量ar)转换到另一组b下*，以新的方式进行表达。  

正如像之前描述的情况，目标测量b可以是所定义的世界空间的。每个旧测量映射将产生对所有单个新测量的贡献，这只是因为a1本身就是根据测量b定义的。并且不对齐而已。  
而然，我们可以显式分析每组一对多情况。例如每个旧测量在新的某个特定测量中一共产生多少贡献（如x轴，这里指的是世界空间的x轴）。  

如果我们查看一个更古早的解释技巧，变轴。实际上是类似概念的一种不明确解释，也许不如测量系统更接近本质和原因。上例中变轴指的是什么呢?  
这里唯一合理的解释是，由于我们只知道a相对于b(创建测量a的参考)的定义，可以轻松找到b1映射到a1的任意关系，因此变轴的是b->a。  
乍一看这似乎非常难以理解，因为与我们的测量转换方向相反！但记住，我们的变换矩阵是相同的(找出列的定义)，因此行为和解释必须相同。  
除此之外我们也可以想象：这里有一个微妙的关系，对于一个`by->ay`的并伴随测量`b[01]`的变换(变轴)，尽管结果中的测量仍然在b中，但该结果点实际上将被a测为`a[01]`。  

## 结合等身矩阵和线性属性的技巧
对于某些计算，这些代数方面的转换是必要的。同样，将技巧放在这里，但他们通过基础事实推断而来(不容易)。  
```ruby
# /v/linear-transformations-as-matrix-vector-products
en = [..?1..+]      # e-col from cols of In
x = Ix              # 是否产生新测量，取决于上下文
  = span(Icols, Cx) # Cx = x.n
  = Σ Cx * en

T(x) = T(↑) = Σ T(x1e1) # 整体变换等于每个变换(可理解为测量)之和
            = Σ x1 T(e1)
           == [T(e1)... ] * x # 注意，在特定变换下, T(e1)的T是列表示的矩阵。
```

## 组合变换计算证明
现在对矩阵乘法进行解释。这只是期望找到具有合并效果的列是什么：  
这种运算在直觉上难点在于无法使用连续变换而计算矩阵结果。  
```ruby
# /v/compositions-of-linear-transformations-2
Cx = B(Ax)

start with C = I    # 为I找到使变换等效的列，构成C

# T(e1) = A(e1)
C = [B(Ae1) ...]    # what is Ae1? => col1 of A...
  = [B*A_c1 ... ]   # gotcha?
```