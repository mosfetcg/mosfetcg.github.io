---
layout: page
title:  "曲线和网格"
author: mosfet
category: scene
tags: 场景 曲线 网格
---
在计算机图形领域，某些测试模型具有标志性名声，如犹他州茶壶(utah teapot)、斯坦福兔子(stanford bunny)。该茶壶是计算机图形学的象征。  
有趣的是，这两个模型是由参数曲面和物理扫描两种方式建模的，为了在光栅管道可用，也被预处理为网格数据。  
```
see, https://en.wikipedia.org/wiki/List_of_common_3D_test_models
```
笔者认为，几乎所有方式表达的模型形式都可以最终被预处理为网格，从根本上来说，网格代表了数学上详细、光滑曲面或者体积数据的近似的存在。  
对象顺序渲染从原图开始处理对象，曲面通常预先计算为网格集合。因此，我们大概可以找到这两种方式各自对于处理曲面的观点差异。  

但我们提出一个有关渲染的疑问来结束这些模型形式的讨论。图像顺序渲染研究的对象通常不是原图，但究竟是否可以在同等数量的情况下渲染它们？答案通常是，很困难，甚至流行的社区中几乎没有演示。
这种计算量超出想象。即使只有少量三角形，也必须使用加速结构。  
单片段着色器的实际实现中，唯一的选择是硬编码它们进行编译，包括可见性结构的测试，完全手工。  

---
## 数学曲线
```
Focg15.
M3d11.
```
曲面本身由数学进行表达，正如我们所熟悉的，图形中经常使用隐式或参数形式。  

数学上指定曲线(curve)有三种形式，**①隐式②参数；③生成程序性曲线。**本文我们不讨论最后一种方式。  
某些曲线的名称由于其形状广为人知，呈现无限或闭环，另一些几乎可以是任何形状，它们是自由(free-form)曲线。  
我们已经发现特定曲线同时存在简单的隐式和参数形式，例如圆形，但通常情况下很难找到参数表示。  

记住曲线是一组点，参数形式在采样上更自由。  
本节主要讨论参数曲线，经常，我们考虑以**标准化**`0..1`域索引曲线。复杂的曲线是由多个参数曲线**划分、合并**构造(divide-and-conquer)的。许多简单的较小零件类型都很实用。我们可能对一条曲线某个位置的观察感兴趣，如曲率、方向。在创建方面，我们期望一条曲线经过我们想要的点，称为插值点。该插值结果的特定域称为插值域。  
实践中，插值方案通常具有不良属性，通常优选近似(approximating)点曲线方案。这种情况下，由**控制点**影响曲线的形状，但不能准确指定通过它们。  

### cubic
立方参数曲线已通过计算机图形应用程序广泛使用。  
```ruby
# cubic curve
# t               0..1
# T(t)=[1tt²t³]  [1, 0..1]
p(t) = a(vec3)+bt+ct²+dt³ {
  x: a.x(1)+b.x(t)+c.x(t²)+d.x(t³)
  y: z:
}
     = [a b c d]*[1,t,t²,t³]
     = C*T(t)
&&
d(pt)/dt = C*dT(t)/dt = C[0,1,2t,3t²]
```
注意，向量视为点或方向配重以**标准化域**的参数`t`的不同配比相加。对于每个向量的组件，也可以视为单独这样做。  
```ruby
p0(t) + p1(1-t)            # move between，配重 线性插值
ro + (t)rd0 + (t²)rd1 + .. # 非线性配重
```

复杂曲线通常由多个较小的碎片组成，透过碎片的端点(endpoints)处连接一起。  
而在两个相邻部分的连接点(join point)上，存在参数连续性和几何连续性的抽象`C^nth/G^nth`。  
C1意味连接点上两者触线方向和大小相同，G1表示仅触线方向相同，数字表示到达相同方向且大小不为0的差分次数。Cn隐含了Gn连续性，除非n的速率是0。G0/C0仅简单表示共享完全相同的端点。  

独特的曲线则由几何约束定义，包括端点位置以及速率。在立方曲线中，因为有四个向量以及4个域衍生的配重，因此具有四个约束。这种形式如下：  
这种表示方法中，左侧括号内的表达式称为拌和函数(blending funciton)，因为可视为某种配重和该向量自身的固定配重的组合。  
通常几何矩阵是约束构成的，而基矩阵通过定义到达特定约束需要的组合配重得到，使曲线在特定约定参数上满足所有约束点。  
```ruby
Q(t) = Σ(ai+bit+cit²+dit³)gi # g ref to constraint
     = [g][a b c d]*T(t)
     = GMT(t)
  # G ref geometry matrix, M ref basis matrix
```

### Hermite
立方Hermite曲线由两个端点P1和P2定义，而速率方向T1和T2在这些端点处。  
通俗来说，这是要求解：
```ruby
H(0)    = [P P T T]M (1,0,0,0) = P1    # recall  [1,t,t²,t³]
D(H(0)) = [P P T T]M (0,1,0,0) = T1    # recall this D(ht) = C[0,1,2t,3t²]
```
基矩阵提供了拌合函数的固定部分，使我们将P1，P2，T1和T2的与各参数配重通过某种方式组合起来。  
```ruby
H(t) = (1-3t²+2t³)p1 + t²(3-2t)p2 + t(t-1)²t1 + t²(t-1)t2
```
在四组拌和函数中，前两个分别在`0/1`域达到`1/0`，这插值了它们。  
若两条Hermite曲线共享一个端点P2，则几何矩阵`Ga,Gb`应该顺序包含三个点的两个，对于`T2`，若速率不匹配`T2a = uT2b`，则达成了`G1`连续性，若完全相等`T2a = T2b`，则满足参数连续性。  

### Bézier
贝塞尔(发音BAY-ZEE-AY)曲线定义任意度(degree)`n`(最高指数)多项式。`n+1`个点称为曲线的控制点。  
第一个以及最后一个控制点P0和Pn通过曲线插值，中间的控制点由曲线近似，拌合函数可从以下序列表达式取得：  
```ruby
B(t) = Σ(k=0..n)B_nk(t)Pk

# Bernstein polynomials(blending functions)
B_nk = [n!/k!(n-k)!] * [t^k(1-t)^n-k]

B_n_k(t) = (1-t)B_n-1_k-1 + tB_n-1_k
B_0_0 = 1, B_n_k = 0 if k<0 || k > n
```
立方贝塞尔曲线具有四个控制点。
```ruby
cubicB(t) = Σ(k=0..3)B3k(t)Pk
          =(1-t)³p0+3t(1-t)²p1+3t²(1-t)p2+t³p3
G = [p0 p1 p2 p3]
B = GMT(t) = G*1 -3  3 -1 
               0  3 -6  3 T(t)
               0  0  3 -3
               0  0  0  1
# check blending functions for the cubic Bézier curve
B_3k(0) = 1 or 0 k=0 || k=123
B_3k(1) = 0 or 1 k=012 || k=3
Σ(k=0..3)B_3k(t) = 1 # 伯恩斯坦多项式之和，对于任意给定t其和都为1
```
一个有用的属性是其形状完全位于其控制点的凸峰中。  
另外，其差分结果显示，端点速率方向是端点以及临近控制点之间的差分的倍数。  
这提供了一种从Hermite和贝塞尔之间简单转换的机制。如果使其两个端点对应p0,p3则存在等式：  
```ruby
DBt = [p0p1p2p3] -3   6 -3
                  3 -12  9 * [1,t,t²]
                  0   6 -9
                  0   0  3
DBt(0) = 3(p1-p0)
Dbt(1) = 3(p3-p2)

p1 = p0+ T1/3
p2 = p3- T2/3
```
#### truncation
当在贝塞尔曲线`Bp(t)`内部`t0..t1`创建新曲线`Bq(u)`，称为截断。  
其中两个控制点(插值)位于参数两端，也位于曲线上，而点`Q1,Q2`(近似)可通过上述方程计算，因此该方程也用于截断曲线计算。  
```ruby
t(u) = t0+(t1-t0)u
Q0 = Bp(t0)
Q3 = Bp(t1)

Bq(u) = Bp(t(u))
dBqu/du = dBp(tu)/dt * dtu/du = (t1-t0)DBp(t0+(t1-t0)u)
T0 = DBq(u=0) = (t1-t0)DBp(t0)  #u=0
T3 = DBq(u=1) = (t1-t0)DBp(t1)  #u=1
Q1 = Q0 + T0/3 = ...# ↑
Q2 = Q3 - T3/3 = ...# ↑
```
#### de Casteljau
De Casteljau算法提供了一种几何构造方式，允许在其参数域`0..1`任意一处`s`将贝塞尔曲线`Bp(t)`细分为吻合的两部分`Bq(u)`和`Br(v)`，于`0..s`和`s..1`。  
```ruby
Q0 = Bp(0) = P0
Q1 = Bp(0) + (s/3)DBp(0)
Q2 = Bp(s) - (s/3)DBp(s)
Q3 = Bp(s)

Q1 = (1-s)P0+sP1 
   = (1-s)Q0+sP1
Q2 = (1-s)[(1-s)P0+sP1]+s[(1-s)P1+sP2]
   = (1-s)Q1+s[(1-s)P1+sP2]

R0 = Bp(s)
R1 = Bp(s) + [(1-s)/3]DBp(s)
R2 = Bp(1) - [(1-s)/3]DBp(1)
R3 = Bp(1) = P3

R2 = (1-s)P2+sP3 
   = (1-s)P2+sR3
R1 = (1-s)[(1-s)P1+sP2]+s[(1-s)P2+sP3]
   = (1-s)[(1-s)P1+sP2]+sR2
```
检查`Q3 = R0`，这是Q2,R1连线对于原曲线的触点。参考Q2、R1方程：  
```ruby
Bp(s) = (1-s)Q2+sR1
```
这显示了算法的基本过程，首先将原始四个控制点相邻连接为三个线段，以以下方式根据`s`对端点进行线性插值产生新点`P0'=Q1,P1',P2'=R2`：  
该过程复发地以`s`进行插值，直到只剩下一个点`P0(3)`。在最后两个等式中，显示了划分曲线的控制点。  
```ruby
Pi(k) = (1-s)Pi+sPi+1  # k=1 -> Pi'

Pi(k) = (1-s)Pi(k-1)+sPi+1(k-1)
so Pi(0) = Pi

Qi = P0(i)
Ri = Pi(3-i)
```