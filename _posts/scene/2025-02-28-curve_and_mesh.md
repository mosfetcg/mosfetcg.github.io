---
layout: page
title:  "曲线和网格"
author: mosfet
category: scene
tags: 场景 曲线 网格
---
在计算机图形领域，某些mesh网格由于其在研究，测试和教育中的广泛使用而获得了标志性的名声。两个最著名的例子是：  
`斯坦福兔子(stanford bunny)`：1994年在斯坦福大学创建的这款兔子的3D模型由69,451个三角形组成。它已广泛用于测试与渲染，压缩和mesh处理相关的算法。  
`犹他州茶壶(utah teapot)`：该茶壶是计算机图形学的象征。它的光滑，对称的表面使其非常适合在着色，照明和渲染技术方面进行早期实验。但它仍然是一种怀旧而实用的教学工具。  

我通常只写图像顺序渲染。它们是否可以处理大型网格？答案通常是，很困难，甚至流行的社区中几乎没有演示。其原因无非是这两种渲染对于曲面的极端看法。  
如果每个像素需要遍历所有三角形，这种计算量超出想象。即使只有少量三角形，至少我们可以想到，利用空间结构进行编排的可能性为99.99%。第二是，使用射线交叉三角形比SDF更快。  

最后就是实际问题，在单个着色器中真的可行吗？唯一的选择是硬编码它们进行编译，包括加速结构的交叉测试，完全手工。  

---
## 为什么是网格？
曲面本身由数学进行表达，正如我们所熟悉的，光线追踪中经常使用隐式或参数形式。  
由于光栅化从原图开始处理对象，曲面通常预先计算为网格集合，以符合**对象顺序渲染**。  
因此，我们可以找到这两种方式各自对于处理曲面的观点差异。  

**(Focg15.)**补充。  
有三种主要方法指定曲线(curve)，本节的曲线不偏向于说明曲面：即①隐式②参数；  
③生成式和程序化曲线。生成某条曲线上的点，但不属于任何前者提供。  

某些形状的曲线的参数形式很容易。例如，线，圆和椭圆。但对于其他许多形状的曲线，找到直接函数可能很难，反之，主要策略是进行划分构造(divide-and-conquer)。必须将目标曲线分解为许多简单的较小零件，每个曲线都有一个简单的描述。  
做到这一点是使用分割域表达多个曲线，随着我们使用越来越多的零件，我们可以获得更好的近似值。**在极限情况下，我们可以准确地表示原始形状。**  

元件的形式：  
```ruby
f(u) = (1-u)PA + uPB            # 2 pos
f(u) = a0 + a1u                 # pos + dir
f(u) = a0 + a1u + a2u^2         # poly quadratics
f(u) = a0 + a1u + a2u^2 + a3u^3 # poly cubic
```
要具体合成它们为一个曲线参数：  
```cpp
f(u) = u in (0..1/2) ? f1(2u) : f2(2u-1)
```

**近似线(approximating curves)**  
控制曲线的最简单方法似乎是指定一组要插值的点。但是，在实践中，插值方案通常具有不良属性，通常优选仅近似点的曲线方案。使用近似方案，**控制点**(不在曲线上)会影响曲线的形状，但不能准确指定。尽管我们放弃了直接指定要通过的点的能力，但我们获得了曲线和局部控制的更好行为。  
最重要的两种近似曲线类型是`Bezier(贝塞尔)`和`B-Spline`曲线。  
三次贝塞尔由四个点控制。有两个位置`p0,p3`在插值中出现，因为`u = 1/0`的情况，中间的点是控制点。  
```ruby
f(u) =(1-3u+3u^2-u^3)p0 +(3u-6u^2+3u^3)p1 +(3u^2-3u^3)p2 +(u^3)p3
```