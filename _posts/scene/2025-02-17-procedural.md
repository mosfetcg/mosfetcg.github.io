---
layout: page
title:  "更真实的环境"
author: mosfet
category: scene
tags: 场景
---
本文不包含特定场景，而是讨论创建有趣、或真实场景的大量实用技术。  
在图形学中，常见的一个词是**程序化(procedural)**，旨在用特定算法生成目标。  
但是程序化技术遍布各个领域，不仅是特定的场景效果，通常也用于动画领域。  

接下来的主题，本质上取决于目的和渲染方式是什么。  
我们使用一个非常普通的渲染器作为示例，使用SDF寻找表面，并启用路径积分。以提供体积渲染的可能性。 
## 物理还是近似？
在大多数情况下，如果我们要达成或模拟一种现象都不是基于物理上严格的，实际上粗略获取相似接近正确的结果也很容易。  
尽管图形学(——模拟)可以很好地对物理、数学元素进行程序表达，但在这个方面也许优先选择程序方案更容易。  
因为，读者或者笔者可能不是精通任何其中之一的人，目前，我认为这不是必要前提，不会让人迷失在理论的缺失中。  

另一个方面从实际考虑，性能——我总是遇到性能问题，甚至还没有到需要应用物理法则的那一步。  
即使条件允许，CPU处理一条指令是由其N倍的硅原子工人完成的，从数量上来看，用计算机模拟真正的现实永远是不可能的。  

第三，出于实践观察。对天空的线性插值高度符合现实，而不需要任何理论，这种方式当然称为程序化的。  
我们处于太阳系中，从太阳获取一切照明，模型在旋转。笔者姑且不认为完全这种渲染是可行的。  
最后我要强调一点思考技巧，图形程序员应该意识到——从观察者的角度思考场景。思考观察者会看见什么，然后再采取行动，因为这就是最终目的。  
即使大气不存在，我们可以令未命中对象的光线返回一个简单颜色，以达成一种大气存在的假象，这就是为什么这种程序化方式很有用且流行的原因之一。  

## 图像天空盒
首先说明最重要的天空盒应该如何制作，如果使用图片作为背景，那么就根本不需要任何操作。  
因此，第一种方式，①使用**图像**在这里一笔带过，典型用法是纹理映射立方体或球形图像。  

## 插值和圆盘
<div class="x la bdl2 pdl2 sk bg-gunmetal05 tx-antiqueRuby1"><pre>
天空穹顶通常是蓝色，太阳光穿过大气层时，短波长的蓝光更容易被散射
水平线方向的天空通常接近白色或浅蓝色。光线在接近地平线时穿过更厚的大气层，更多的蓝光被散射掉，剩余的光线混合后呈现白色或浅蓝色

当太阳位于斜向时，天空的颜色会进一步变化，水平线可能带有黄色、橙色或红色的色调。
光线需要穿过更长距离的大气层。更多的蓝光被散射掉，剩余的光线中波长较长的红光和黄光占比增加。
在接近日出或日落时，这种现象尤为明显。蓝光被大量散射，红光和黄光占主导，天空会呈现暖色调（如橙色或红色）。

如果大气中有较多颗粒物（如灰尘、雾霾等），天空的颜色可能会更偏向灰白色或浅黄色。

时间      头顶天空颜色  水平线天空颜色
日出/日落 深蓝色或紫色  橙色、红色或粉红色
上午/下午 明亮的蓝色    浅蓝色或白色
正午     明亮的蓝色    浅蓝色或白色
夜晚     深蓝色或黑色  深蓝色或黑色</pre>
</div>
基本的程序性背景总是比图像更好。最普通的情况下，包括插值天空颜色，噪声生成的云层、天体的圆盘等。我们将云放在下一节，因为有一些额外问题要说明。  

这个方法可以扩展到完全动画。例如增加一个全局时间来表现不同的背景。大气的颜色和圆盘轨迹必须变化。  
实际上，笔者在大多数情况下都使用了它们。而然，它们本质上不是真正的对象，理论上无法直接参与场景照明，最后必然出现单独着色的尴尬情况。  
为了使云可以参与照明，一种方式是参考并近似正确结果，本文对正确结果的定义来自于**体积渲染(volumetric rendering)**。即使是体积渲染，它也结合另一些常见技术，其数据仍然可以使用相同的3D噪声。  

由于缺乏对象，这个系统中本身所含的要素，即大气和云、圆盘等根本不能利用任何着色模型来进行着色。本质上它们需要单独"画上去"，从而使正确结果需要更多思考。  
```cpp

```

## 球面
我遇到的一个长期误解是，观察者的可视范围实际上并不是半球，这导致了一些错误的云分布以及视觉错误。  
从形状来看所处的水平面上方到大气边缘是一个圆段(segement)。越水平，那么边缘的距离越大。在地球上这种现象非常明显，圆段的高度很扁，而地面非常宽。  

远处的云通常很小，接近地平线。假设高度相同，每个方向上仍然可能看到云，显示的不同之处在于大小。这种差异在现实中很明显。
密集的云层仍然在外部显示白色，薄者显露背景，一种丝状的感觉，被太阳直接照明发的密集且厚度高的，底部将额外呈现黑影。

## 使用体积云
我们特地将处理云滞后。在处理近似方式前，必须先看看体积云是什么样的。事实上，这些对象在任何时间点都具有相当不错的结果。  
将FBM噪声作为**参与介质**渲染可以获得具有正确光照的云。在场景中放置一个体积盒子就可以解决问题。  
<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item4-lg item12 pd0">
      <img src="/assets/i/6-1.png">
    </div>
    <div class="x la item4-lg item12 pd0">
       <img src="/assets/i/6-2.png">
    </div>
    <div class="x la item4-lg item12 pd0">
       <img src="/assets/i/6-3.png">
    </div>
  </div>
  <p>图1：使用体积云</p>
</div>

## 近似更简单的云
使用2D噪声可能会遇到一些纹理映射问题，因此最好直接使用3D版本。  
对于3D版本的噪声和FBM，需要读者先理解1D、2D版本。借助现代工具——AI来查找代码，另外分析错误也很有效，特别是一些奇怪的命中交叉问题。  

如前所述，它们通常很难正确着色。注意使用多个密度，如击中`y=1.3`和`y=1.0`即可，这几乎总是比单个密度更好，云层更有层次感，显著减少高密度的聚集或者扁平感。  
当您直接加入使用这些密度的白色值很容易使得天空过亮。而晚上或者傍晚则很难、甚至无法近似出正确的颜色。请观察之前的结果，傍晚只有边缘会变成橘色，夜晚的云层仍然相对保持白色。  

我只在白天使用这些。  
```cpp
// 3 云
// fbm(p + fbm(p))
// float cloud_density = fbm(p + fbm(p, 0.5, 3.0, 0.25), 0.5, 3.0, 0.25);
float t1 = 1.0 / v.y;
float t2 = 1.2 / v.y;
vec3 p1 = t1 * v * 5.0 + wind_dir * u_z * 0.01 + u_time * wind_dir;
vec3 p2 = t2 * v * 5.0 + wind_dir * u_z * 0.01 + u_time * wind_dir;
float dense1 = fbm(p1 + fbm(p1, 0.5, 2.0, 0.5), 0.5, 2.0, 0.5);
float dense2 = fbm(p2 + fbm(p2, 0.5, 2.0, 0.5), 0.5, 2.0, 0.5);

float horizon_factor = smoothstep(0.1, 0.3, v.y);
float view_factor = (v.y + 1.0) / 2.0;

dense1 = smoothstep(0.4, 0.6, 0.5 * (dense1 + dense2) * horizon_factor * view_factor);
vec3 bg = sky * ENV_LIGHTSOURCE + sun_disk + vec3(star) * (1.0 - sun_lambertian);
return mix(bg, vec3(1.0), dense1);
```

<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item4-lg item12 pd0">
      <img src="/assets/i/6-4.png">
    </div>
  </div>
  <p>图2：近似结果</p>
</div>

## 环境光遮蔽
环境光遮蔽用于计算更好的环境着色。它的结果模拟了表面处于环境光中曝光后的阴影。  
符合环境光源定义的通常是天空，最后乘以该遮挡。  

遮蔽值描述了这样一种情况，对于特定表面光线可能在许多方向上被其他表面遮挡，遮挡越多，该地区就越闭塞，使得它们在环境光的照明下越少。  
```cpp
float ambient_occlusion( in vec3 p, in vec3 n, in float maxDistance, in float falloff) {
  float ao = 0.0;
  const int samples = 4;

  for (int i = 0; i < samples; i++) {
    float move_off = random(float(i)) * maxDistance;
    vec3 direction = n * move_off;
    ao += (move_off - max(scene(p + direction), 1.0)) / maxDistance * falloff;
  }
  return clamp(1.0 - ao / float(samples), 0.0, 1.0);
}
```

## 便宜的雾
实际上，雾比我们大多数人认为的更普遍。大多数情况下，空气中都有一定程度的阴霾。即使只有少量，我们也可以通过引入雾气来增强室外场景的现实主义。  
除了使用参与介质，存在多种模拟雾的模型。即使是非常简单的方法也可以有效。  
一种这样的方法是基于相机到目标的距离，直到插值到雾本身的颜色。下列是一种非常简单的雾算法。  
```cpp
vec3 fog2( in vec3 col, float d, float start, float end) {
  float amount = clamp(((end - d) / (end - start)), 0.0, 1.0);
  return mix(vec3(0.7, 0.8, 0.9), col, amount);
}
```

## 水下尖刻(caustics)
水底地板上观察到弯曲的光带(bands of ligh)称为`水尖刻(water caustics)`，这是由波浪带传递到下表面的聚光。  
模拟这种基本水下效应可以通过实际追踪射线得到，但是，在大多数情况下，不必完全准确，粗略的模拟也足以传达水下效应。找到与水面上的波一致的方式弯曲的白线就足够了。因此，扭曲相同的波。  
```cpp
float caustic_noise = pow(1.0 - abs(sin(fbm(ro.xy) * 6.28)), 16.0);
vec3 caustic = clamp(sqrt(vec3(caustic_noise) * col2), vec3(0.0), vec3(1.0));
waterfloor = clamp(waterfloor + caustic, vec3(0.0), vec3(1.0));
```
在没有处理水下对从水面进入的光的反应时，你绝对想要尖刻。  
