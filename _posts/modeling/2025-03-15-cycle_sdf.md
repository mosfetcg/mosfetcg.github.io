---
layout: page
title:  "循环场"
author: mosfet
category: modeling
tags: 隐式建模 符号距离函数
published: false
---

## 门格海绵
域重复技术的推导，基本合成方法练习。  
https://en.wikipedia.org/wiki/Menger_sponge

**缩放图形**  
以某种形式缩放了场，图形大小1/a。  
```ruby
sd(p * a) / a;
```

**关于域重复**  
要将平铺重复扩展到3D，我们可能会习惯性地想到一般索引方法——`fract`(见平铺)，但这样创建的单元域是否符合目的取决于情况。  
当2D域从左上角开始并分割，那么每个单元也从左上角开始并相似。对于其他情况，我们只能说取决于fract本身的处理。  
回想一下，3D距离场的评估中心必须在零点，因此可能被分割图形，为了能匹配"形状"，还需移动单元部分，这就是fract自身带来的差异。  
```ruby
vec3 unit_f = fract(p)
```
另一种解决方法是`round`。这些整数原子将吸附其附近的评估点，并视为它自己中心的场，只需要减去该整数向量返回原点完成仿射。  
更好的是，它对于原点也有很好的对称功能！  
```ruby
p - round(p)
```

每个相同的场本质上只是评估不同位置的相同情况，而根本不涉及for循环。  
我们还可以希望每个SDF的副本彼此略有不同。该round整数确实是它们的唯一标识符，因此使用它来重新定义单元的场图形。  

**瓷砖破坏**  
一组临近单元边缘处的场看起来不是连续的，因为每个单元基于自己的ID定义，它们的随机性变化很容易产生"跨界线"。  
最接近的形状反而可以在相邻的瓷砖中。因此，我们要做的就是检查相邻的瓷砖并评估那里的SDF，并找到与任何一个的最接近距离。这听起来像是许多额外的SDF评估，但幸运的是，我们只需要探索确实有机会托管最接近当前实例的邻居。  
通俗的来说，在1D单元中，如果P靠近单元的左侧(一般)，就只需要再评估其左侧邻居，否则为右侧。  
```cpp
float repeated(vec2 p, float s) {
  vec2 id = round(p / s);
  vec2 o = sign(p - s * id); // neighbor offset direction

  float d = INF;
  for (int j = 0; j < 2; j++)
    for (int i = 0; i < 2; i++) {
      vec2 rid = id + vec2(i, j) * o;
      vec2 r = p - s * rid;
      d = min(d, sdf(r));
    }
  return d;
}
```

**边界**  
在实践中使用我们的无限网格重复技术，我们应该以某种方式限制其范围。这样做的天真方法是执行外盒相交。  
您应该意识到SDF实际上是不正确的。该解决方案非常简单，我们不是在3D空间中进行取舍，而是在实例的ID值中进行。  
我们只使用无限或常规域重复技术，但是检查实例标识符`ID`是否在有效实例的范围内。在如果ID不在该范围之外，我们将其夹住/将其限制为我们的有效范围。  
```cpp
rid = clamp(rid, -(size - 1.0) * 0.5, (size - 1.0) * 0.5);
vec2 r = p - s * rid;
d = min(d, sdf(r));
```
与原始无限重复相比，需要的一切是一行代码。  