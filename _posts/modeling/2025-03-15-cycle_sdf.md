---
layout: page
title:  "循环场"
author: mosfet
category: modeling
tags: 隐式建模 符号距离函数
published: false
---

## 场构造
```ruby
/*2D旋转、展开*/
sd_revolution sd_extrusion
/*圆角*/
sd - rad
/*洋葱*/
abs(sd)-thickness

/*组合*/ sd_union sd_subtract sd_intersect sd_xor
/*平滑组合、缓和*/ sd_sunion sd_ssubtract sd_sintersect

/*仿射*/
sd(p - origin)     #球length(p - origin) - 1.0;
sd(rot * p);
/*均匀缩放*/
sd(p * a) / a;     #以某种形式缩放了场，图形大小1/a

/*对称*/ sd_symX sd_symXZ
/*重复*/            # 见下

/*位移贴图*/
sd+move
/*扭曲 弯折*/
```

**关于缓和**  
比普通组合运算符更"平滑"，不仅有助于将形状聚合在一起，而且还可以用它们塑造有机形状，就像图元是用粘土制成的一样。  
简单来说，这种函数对两个场的中间进行插值。  

## 门格海绵
```
https://en.wikipedia.org/wiki/Menger_sponge
```
域重复技术的推导。  

**关于域重复**  
要将平铺重复扩展到3D，我们可能会习惯性地想到一般索引方法——`fract`(见平铺)，但这样创建的单元域是否符合目的取决于情况。  
当2D域从左上角开始并分割，那么每个单元也从左上角开始并相似。对于其他情况，我们只能说取决于fract本身的处理。  
回想一下，3D距离场的评估中心必须在零点，因此可能被分割图形，为了能匹配"形状"，还需移动单元部分，这就是fract自身带来的差异。  
```ruby
vec3 unit_f = fract(p)
```
另一种解决方法是`round`。这些整数原子将吸附其附近的评估点，并视为它自己中心的场，只需要减去该整数向量返回原点完成仿射。  
更好的是，它对于原点也有很好的对称功能！  
```ruby
p - round(p)
```

每个相同的场本质上只是评估不同位置的相同情况，而根本不涉及for循环。  
我们还可以希望每个SDF的副本彼此略有不同。该round整数确实是它们的唯一标识符，因此使用它来重新定义单元的场图形。  

**瓷砖破坏**  
一组临近单元边缘处的场看起来不是连续的，因为每个单元基于自己的ID定义，它们的随机性变化很容易产生"跨界线"。  
最接近的形状反而可以在相邻的瓷砖中。因此，我们要做的就是检查相邻的瓷砖并评估那里的SDF，并找到与任何一个的最接近距离。这听起来像是许多额外的SDF评估，但幸运的是，我们只需要探索确实有机会托管最接近当前实例的邻居。  
通俗的来说，在1D单元中，如果P靠近单元的左侧(一般)，就只需要再评估其左侧邻居，否则为右侧。  
```cpp
float repeated(vec2 p, float s) {
  vec2 id = round(p / s);
  vec2 o = sign(p - s * id); // neighbor offset direction

  float d = INF;
  for (int j = 0; j < 2; j++)
    for (int i = 0; i < 2; i++) {
      vec2 rid = id + vec2(i, j) * o;
      vec2 r = p - s * rid;
      d = min(d, sdf(r));
    }
  return d;
}
```

**边界**  
在实践中使用我们的无限网格重复技术，我们应该以某种方式限制其范围。这样做的天真方法是执行外盒相交。  
您应该意识到SDF实际上是不正确的。该解决方案非常简单，我们不是在3D空间中进行取舍，而是在实例的ID值中进行。  
我们只使用无限或常规域重复技术，但是检查实例标识符`ID`是否在有效实例的范围内。在如果ID不在该范围之外，我们将其夹住/将其限制为我们的有效范围。  
```cpp
rid = clamp(rid, -(size - 1.0) * 0.5, (size - 1.0) * 0.5);
vec2 r = p - s * rid;
d = min(d, sdf(r));
```
与原始无限重复相比，需要的一切是一行代码。  

---
## 推导平面的场
回想一下`dot`的投影模型使用。我们解释，评估位置`p`的一个向量指向原点(即其自身的位置)，另一个视为稍后用于定义平面的标准向量(注意，它很难"够到"与p相同的长度)，因此仅指示该空间中的某个方向并为其远处所对的正交平面定义相对旋转角度(平面在原点处，即与p有关，而不是标准向量的末端)。  
根据投影，现在斜边`p`和夹角已知，并且标准向量长度为1，因此这个剩下的乘积就是标准向量所沿的直角边，基本上这就是到平面的"距离"的最准确定义。  
我们完成了任何相对旋转角度的平面距离场，这将适用于比，评估纯粹轴平行零平面和特定轴高度差的情况，更复杂的情况。  
形状上，这些场是无数平行线(或平面)构成的。  
<div class="x la bdl2 pdl2 mgb3 sk bg-gunmetal05 tx-antiqueRuby1">
✅回顾参数曲面<br>
数学上，参数曲面只需要精确扫描域就完成了。对比之下隐式方程可能需要搜索更多不直接相关的域来"碰撞"出零值环。<br>  
但您如何找到它们的交叉方法？</div>

现在我们有几个看似相关的实际问题。  
我们可能很希望对平面场进行偏移(前文的常规技术)并仍然具有正确的场，尤其是偏移数据来自于参数函数，使用SDF评估点的一部分进行参数化，因此在过程中扫描该曲面数据。  
现在要记住平面场向下的距离定义为什么是正确的(以及我们返回什么)，即n的方向**确实**最近；但是如果我们把曲面放在上面呢？**实际距离**可能不在当前参数(即应该落在曲面的附近)，但我们仍然使用了不经思考的平面距离+偏移。  
我们还可以同时从两种角度思考这个问题，下列情况的思考切入点不同，但都存在相同的问题！  
```
   p  p  p
       ?/|  2 无法确定下方(原先的差异方向)代表"距离"的正确性、因此破坏了局部距离场
   .  .  .  无论我们是完全参数化，还是像评估场一样仅检查曲面的一个位置，这种情况都存在，曲面由其本身表达
/\/\/\/\/\  1 假设完全参数化曲面信息

         p  1 假设我们先有场，再局部偏移
       / |  2 n方向一定是距离吗？这也是错的，因为需要知道曲面的信息
      ?  /\
----------  
```
从结果上看，这将导致评估的场不准确。即——无法看见参数曲面的"零"面。也无法完成正确的偏移。这导致了我们在两个问题上都失败了，偏移面和参数曲面的可见性。  

## 地形交叉
既然无法找出正确的场，是否意味着没有办法了？我们可以转向交叉方法来解决问题，您的目的无非是找到交点，而不是场的正确性，场仅提供参考距离。  
实践中，我们可以以相当小的步长光线行进而不是错误的距离场，这很难错过表面，这基本上是一种直接且正确的渲染参数表面的方式。  

我们找到还未交叉的路径称为蓝色路线，直到越过曲面并翻到下面(py < fh)到达黄色路线，交点就在之间**插值**。  
当然，这种方式单独处理了交叉，并且和其他SDF行进不共用(还需要单独计算normal)，我们可能需要至少分别进行两次行进，然后比较t值的覆盖情况。  
实践中通常需要根据视线距离减少**精度**，因为远处的曲面细节很少，因此我们可以将误差增加到与之相关，这可以节省大量渲染时间。  

---
## 加速结构
另一个优化是加速结构。迭代结构使得SDF的成本过高，我们可以做的是避免不必要的SDF。  
最简单的策略是基本边界体积，如果距离场已经给出比包围体更小的距离，那么为什么还要评估整个SDF呢？  
边界体积不必是球体和盒子之类的封闭形状，它们也可以是半空间。创建排除地面的边界体积几乎是必备的。水平面到地面最高特征(鹅卵石、岩石、灌木丛)之间的边界体积，可以有效避免在近地处绑定复杂地面的评估，这有利于解决地面的可见性非常差的问题，以便我们只是简单的计算角色和树木之类的东西。  
对于复杂情况，层次结构、把对象分配到空间树各个角落可能有用。  